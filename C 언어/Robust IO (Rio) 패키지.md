## Robust I/O (Rio) 패키지

### Rio_readn

- 파일 디스크립터에서 'n' 바이트 만큼의 데이터를 읽고, 요청한 바이트 수가 모두 읽힐 때까지 계속해서 읽기 작업을 수행합니다.

시그니쳐 

```c
ssize_t Rio_readn(int fd, void *usrbuf, size_t n);
```

- "fd" : 읽기 작업을 수행할 파일 디스크립터
- "usrbuf":  읽은 데이터를 저장할 버퍼의 포인터입니다
- "n": 읽어들일 바이트 수입니다.



- Rio_readen 함수는 요청한 바이트 수가 모두 읽힐 때까지 계속해서 읽기 작업을 수행합니다. 따라서, 읽기 작업이 완료되기 전에 파일의 끝에 도달하거나 오류가 발생하면, 함수는 남은 바이트 수와 실제로 읽은 바이트 수의 차이를 반환합니다.
- Rio_readen 함수는 읽기 작업이 완료되면 읽은 바이트 수를 반환합니다. 오류가 발생하면 -1을 반환.



### Rio_writen

"Rio_writen" 함수는 "write" 시스템 콜을 wrapping하여, 데이터를 안전하게 송신하는 함수입니다. "Rio_writen" 함수는 지정된 파일 디스크립터에 데이터를 쓰는데, 이때 지정된 데이터의 크기만큼 모두 쓰여질 때까지 쓰기 작업을 계속합니다.

시그니쳐

```c
ssize_t Rio_writen(int fd, void *usrbuf, size_t n);
```

- "fd": 데이터를 쓸 파일 디스크립터 입니다.

- "usrbuf": 쓸 데이터가 저장된 버퍼의 주소입니다.

- "n": 쓸 데이터의 크기 입니다.

  

"Rio_writen" 함수는 "write" 시스템 콜을 반복하여 호출하여, 데이터를 안전하게 송신합니다. 이때 "write" 시스템 콜이 중단 될 수 있으므로, 함수는 "write" 시스템 콜이 모든 데이터를 쓰는데 성공할 때까지 반복하여 호출합니다. 함수가 종료 될때는 실제로 쓰여진 데이터의 크기를 반환

"Rio_wirten" 함수는 송신 버퍼에 있는 데이터가 모두 전송되었는지 확인하기 위해 write 시스템 콜의 반환값과 예상치가 다를 경우, 다시 write 시스템 콜을 호출하여 데이터를 전송합니다. 이렇게 함으로써, 데이터의 일부가 손실되는 문제를 예방할 수 있습니다.



### Rio_readinitb

"Rio_readinitb"함수는 "rio_t"구조체를 초기화하는 함수입니다. "rio_t" 구조체는 안전하게 데이터를 읽기 위한 버퍼링 기능을 제공합니다.

시그니쳐

```c
void Rio_readinitb(rio_t *rp, int fd);
```

- "rp" 초기화할 "rio_t" 구조체 포인터입니다.

- "fd": 읽을 파일 디스크립터 입니다.

  

"Rio_readinitb" 함수를 호출하여 "rio_t" 구조체를 초기화한 후, "Rio_readlineb" 또는 "Rio_readnb" 함수를 사용하여 데이터를 읽습니다.  "Rio_readlineb" 함수는 특정 문자열이 나올 때까지 데이터를 읽고, "Rio_readnb" 함수는 지정된 바이트 수만큼 데이터를 읽습니다. "rio_t" 구조체는 이러한 함수들을 호출할 때마다 데이터를 읽어들이며, 버퍼링하여 새로운 "read" 시스템 콜을 줄일 수 있습니다. 이렇게 함으로써, 데이터를 안전하게 읽을 수 있고, 파일 디스크립터의 상태를 변경하지 않고 여러 번 읽을 수 있습니다.



### Rio_readlineb

Rio_readlineb함수는 rio_t 구조체에서 특정 문자열이 나오기 전까지 데이터를 읽는 함수입니다.  이 함수는 Rio_readinitb 함수로 초기화한 rio_t 구조체를 사용하여 데이터를 안저하게 읽습니다.

시그니쳐

```c
ssize_t Rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);
```

- "rp" : 데이터를 읽을 rio_t 구조체의 포인터입니다.

- "usrbuf" : 읽은 데이터를 저장할 버퍼의 포인터 입니다.

- "maxlen" : 읽을 데이터의 최대 길이 입니다.

  

`Rio_readlineb` 함수는 `rio_t` 구조체에 저장된 버퍼에서 문자열이 끝나는 위치를 찾기 위해, 개행 문자(`\n`)을 찾습니다. 이때 `maxlen` 길이를 넘어가면 데이터를 잘라버리고, 오류를 반환합니다. 만약 개행 문자를 찾지 못하면, 더 많은 데이터를 읽어들이기 위해 `read` 시스템 콜을 호출합니다. 따라서 `Rio_readlineb` 함수는 안전하게 문자열을 읽을 수 있고, 버퍼 오버런 문제도 방지할 수 있습니다.

### Rio_readnb

Rio_readnb 함수는 rio_t 구조체에서 주어진 크기만큼의 테이터를 안전하게 읽는 함수입니다. 이 함수는 Rio_readinitb 함수로 초기화한 rio_t 구조체를 사용하여 데이터를 안전하게 읽습니다.

시그니쳐

```c
ssize_t Rio_readnb(rio_t *rp, void *usrbuf, size_t n);
```

- "rp " : 데이터를 읽을 "rio_t" 구조체의 포인터입니다.
- "usrbuf" : 읽은 데이터를 저장할 버퍼의 포인터입니다.

- "n" : 읽을 데이터의 크기입니다.

  

`Rio_readnb` 함수는 `read` 시스템 콜을 사용하여 `n` 바이트 만큼의 데이터를 안전하게 읽어옵니다. 이때 데이터를 버퍼에 다 쓰기 전에 `read`가 반환될 수 있으므로, 필요한 만큼 다시 호출하여 데이터를 모두 읽을 때까지 반복해서 읽어들입니다. 따라서 `Rio_readnb` 함수는 안전하게 데이터를 읽을 수 있고, 버퍼 오버런 문제도 방지할 수 있습니다.



### Mmap

Mmap 함수는 파일이나 기타 객체를 메모리에 매핑하는 시스템 콜입니다. 이 함수를 호출하면 파일을 메모리에 매핑하여 파일을 읽고 쓰는 것처럼 메모리를 다룰 수 있습니다.

Mmap 함수는 다음과 같은 형식으로 호출합니다.

```c
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```



- addr : 메모리 영역의 시작 주소, 일반적으로 0을 지정
- length : 메모리 영역의 크기를 지정. 이 값은 보통 파일의 크기와 같거나 크게 지정
- prot : 메모리 영역의 보호 모드를 지정합니다. 읽기 전용, 쓰기 전용, 실행 전용
- flags: 메모리 영역의 속성을 지정, 주로 매핑 방식과 관련된 속성을 설정
- fd : 매핑할 파일의 파일 디스크립터입니다. 파일을 매핑하지 않을 경우에는 -1dmf wlwjd
- offset : 매핑할 파일의 시작 위치를 지정



mmap 함수를 사용하면 파일을 메모리에 매핑하여 파일을 읽고 쓸 수 있습니다. 예를 들어, 파일의 내용을 메모리에 매핑하면 파일의 내용을 읽는 것과 같이 메모리에서 파일의 내용을 읽고 쓸 수 있습니다. 이를 통해 I/O 성능을 향상 시킬 수 있습니다.

또한 mmap 함수를 사용하면 여러 프로세스가 동시에 메모리에 매핑된 파일에 접근할 수 있습니다. 따러서 mmap 함수는 IPC(Inter-Process Communication) 기법으로 사용될 수 있습니다.



### mnumap

mnumap은 mmap으로 매핑한 가상 주소 공간을 해세하는 함수입니다.  munmap은 성공하면 0을 반환하고 실패하면, -1을 반환

mnumap 함수의 원형

```c
int munmap(void *addr, size_t length);
```

addr은 mmap을 함수로 매핑한 가장 주소를 지어하며, length는 매핑한 메모리의 크기를 지정



먼저, HTTP/1.0 GET 요청을 처리하는 기본 순차 프록시를 구현해야 합니다. POST와 같은 다른 요청 유형은 선택 사항입니다. 프록시가 시작되면 명령줄에서 지정된 포트 번호에서 들어오는 연결을 대기해야 합니다. 연결이 설정되면 프록시는 클라이언트로부터 전체 요청을 읽고 요청을 구문 분석해야 합니다. 클라이언트가 유효한 HTTP 요청을 보냈는지 확인한 다음, 해당 웹 서버에 대한 자체 연결을 설정하고 클라이언트가 지정한 객체를 요청해야 합니다. 마지막으로, 프록시는 서버의 응답을 읽고 클라이언트로 전달해야 합니다.