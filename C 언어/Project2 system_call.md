Project2 :User Programs

Pintos와 그 인프라 및 스레드 패키지를 사용하여 작업하면서 사용자 프로그램을 실행할 수 있는 시스템 부분에 대해 작업하기 시작해야 합니다. 기본 코드는 이미 사용자 프로그램을 로드하고 실행할 수 있지만 I/O나 상호작용은 불가능합니다. 이 프로젝트에서는 시스템 호출을 통해 프로그램이 OS와 상호작용할 수 있도록 만들어야 합니다. 이 과제에서는 userprog 디렉토리에서 작업하게 될 것이지만 Pintos의 거의 모든 다른 부분과 상호작용해야 합니다. 아래에서 관련된 부분을 설명하겠습니다.

프로젝트 2는 프로젝트 1의 결과물 위에 구축해야 합니다. 프로젝트 1의 코드는 프로젝트 2의 코드에 영향을 미치지 않지만, 여전히 프로젝트 1의 테스트 케이스를 통과해야 합니다. 이것은 점진적인 프로젝트이기 때문입니다.

또한, 프로젝트 2에는 추가적인 도전 과제가 있음을 알려주시기 바랍니다. 이는 선택적인 구현이며, 해당 도전 과제에 대한 스켈레톤 코드는 테스트 케이스를 제외하고는 제공되지 않습니다. 모든 디자인은 여러분에게 달려 있습니다. 추가 요구사항을 제출하고 테스트하려면 userprog/Make.vars 파일을 수정해야 합니다.

마지막으로, TODO가 없는 코드는 항상 변경할 필요가 없다는 것은 아니며, 프로젝트 2의 모든 소스 코드를 자유롭게 수정할 수 있지만 테스트 코드는 제외됩니다.

지금까지 Pintos에서 실행한 모든 코드는 운영 체제 커널의 일부였습니다. 이는 예를 들어 지난 과제에서의 모든 테스트 코드가 시스템의 권한이 있는 부분에 대한 완전한 액세스 권한을 갖는 커널의 일부로 실행된다는 것을 의미합니다. 그러나 운영 체제 위에 사용자 프로그램을 실행하기 시작하면 이는 더 이상 사실이 아닙니다. 이 프로젝트는 이러한 결과에 대한 처리를 다룹니다.

여러 프로세스를 동시에 실행할 수 있도록 허용합니다. 각 프로세스에는 하나의 스레드가 있으며(multithreaded 프로세스는 지원되지 않음), 사용자 프로그램은 자신이 전체 기계를 사용하고 있다는 착각 속에서 작성됩니다. 따라서 여러 프로세스를 동시에 로드하고 실행할 때, 이러한 착각을 유지하기 위해 메모리, 스케줄링 및 기타 상태를 올바르게 관리해야 합니다.

이전 프로젝트에서는 테스트 코드를 커널에 직접 컴파일하여 커널 내에서 특정한 함수 인터페이스를 요구해야 했습니다. 이제부터는 사용자 프로그램을 실행하여 운영 체제를 테스트합니다. 이로 인해 훨씬 더 많은 자유도가 생깁니다. 사용자 프로그램 인터페이스가 여기에 설명된 사양을 충족하도록 해야 하지만, 이러한 제약 조건을 고려하면 커널 코드를 원하는 대로 다시 구성하거나 재작성할 수 있습니다. 모든 코드는 #ifdef VM 블록에 포함되지 않아야 합니다. 이러한 블록은 프로젝트 3에서 구현할 가상 메모리 하위 시스템을 활성화한 후에 포함됩니다. 또한, 코드가 #ifndef VM으로 묶여 있다면 해당 코드는 프로젝트 3에서 생략됩니다.

시작하기 전에 동기화와 가상 주소를 반드시 읽으시기를 권장합니다.

이번 프로젝트에서는 파일 시스템 코드와 인터페이스해야 합니다. 왜냐하면 사용자 프로그램이 파일 시스템에서 로드되고 구현해야 하는 많은 시스템 호출이 파일 시스템과 관련이 있기 때문입니다. 그러나 이번 프로젝트의 주요 관심사는 파일 시스템이 아니므로, filesys 디렉토리에 간단하지만 완전한 파일 시스템이 제공됩니다. 파일 시스템을 사용하는 방법과 특히 제한 사항을 이해하기 위해 filesys.h 및 file.h 인터페이스를 검토해보는 것이 좋습니다.

이번 프로젝트에서 파일 시스템 코드를 수정할 필요는 없으며, 수정하지 않는 것이 좋습니다. 파일 시스템 작업은 이번 프로젝트의 주요 관심사에서 벗어나는 것입니다.

이제 파일 시스템 루틴을 올바르게 사용하면, 파일 시스템 구현을 개선하는 프로젝트 4에서 매우 유용할 것입니다. 그 때까지는 다음과 같은 제한 사항을 감수해야 합니다.

이 프로젝트에서는 파일 시스템 코드와 인터페이스해야 하므로, 사용자 프로그램은 파일 시스템에서 로드되며 구현해야 할 많은 시스템 호출이 파일 시스템과 관련이 있습니다. 그러나 이 프로젝트의 초점은 파일 시스템이 아니므로, filesys 디렉토리에 간단하지만 완전한 파일 시스템이 제공됩니다. 파일 시스템을 사용하는 방법 및 특히 많은 제한 사항을 이해하기 위해 filesys.h 및 file.h 인터페이스를 살펴보는 것이 좋습니다.

이 프로젝트에서는 파일 시스템 코드를 수정할 필요가 없으며, 수정하지 않는 것을 권장합니다. 파일 시스템에서 작업하는 것은 이 프로젝트의 초점에서 벗어날 수 있습니다.

파일 시스템 루틴의 적절한 사용은 프로젝트 4에서 파일 시스템 구현을 개선할 때 매우 유용할 것입니다. 그 전까지는 다음과 같은 제한 사항을 용인해야 합니다:

- 내부 동기화 없음. 동시 접근이 서로 간섭할 수 있습니다. 파일 시스템 코드를 실행하는 프로세스가 한 번에 하나만 실행되도록 동기화를 사용해야 합니다.
- 파일 크기는 생성 시 고정됩니다. 루트 디렉토리는 파일로 표시되므로 생성할 수 있는 파일 수도 제한됩니다.
- 파일 데이터는 단일 extent로 할당됩니다. 즉, 단일 파일의 데이터는 디스크의 연속적인 섹터 범위를 차지해야 합니다. 시간이 지남에 따라 파일 시스템을 사용하면 외부 단편화가 심각한 문제가 될 수 있습니다.
- 서브 디렉토리 없음
- 파일 이름은 14자로 제한됩니다.
- 작업 중 시스템이 충돌하면 디스크가 자동으로 복구되지 않는 방식으로 손상될 수 있습니다. 또한 파일 시스템 복구 도구가 없습니다.



중요한 기능 중 하나는 다음과 같습니다:

filesys_remove()의 Unix와 유사한 의미론적 기능이 구현되어 있습니다. 즉, 파일이 열려 있을 때 삭제하면 해당 블록이 해제되지 않으며, 마지막으로 해당 파일을 닫을 때까지 여전히 열려있는 스레드에서 액세스할 수 있습니다. 자세한 내용은 열린 파일 삭제를 참조하세요.

유저 프로그램 작동 방식 Pintos는 일반적인 C 프로그램을 실행할 수 있습니다. 이 프로그램들은 메모리에 맞고, 구현된 시스템 호출만 사용해야 합니다. 특히, 메모리 할당을 위한 malloc()은 구현할 수 없습니다. 이번 프로젝트에서 구현한 시스템 호출은 메모리 할당을 허용하지 않기 때문입니다. Pintos는 또한, 커널이 스레드를 전환할 때 프로세서의 부동 소수점 단위를 저장하고 복원하지 않기 때문에 부동 소수점 연산을 사용하는 프로그램도 실행할 수 없습니다.

Pintos는 Linux, Solaris 등 많은 운영체제에서 사용하는 오브젝트 파일, 공유 라이브러리, 실행 파일을 위한 파일 형식인 ELF(executable and linking format)를 로드할 수 있습니다. 이 프로젝트에서는 userprog/process.c에서 제공하는 로더를 사용하여 ELF 실행 파일을 로드합니다.

실제로, x86-64 ELF 실행 파일을 출력하는 어떤 컴파일러와 링커를 사용하여도 Pintos에 대한 프로그램을 만들 수 있습니다. (그러나 Pintos에서 제공하는 컴파일러와 링커를 사용하는 것이 좋습니다.) 유용한 작업을 수행하기 위해서는 시뮬레이션 파일 시스템에 여러 프로그램을 복사해야 합니다. 따라서 필요한 경우, 파일시스템을 초기화한 후, 이를 복사하여 필요할 때마다 이용할 수 있도록 하면 됩니다. 이 때, 파일시스템을 잘못 사용하여 불가용하게 만들었을 때는, 복사한 파일시스템으로 복원하는 것이 유용합니다.



## System Call

시스템 콜 인프라를 구현하세요.

userprog/syscall.c에서 시스템 콜 핸들러를 구현하세요. 제공되는 뼈대 구현은 시스템 콜을 프로세스 종료로 처리합니다. 시스템 콜 번호를 검색한 다음, 시스템 콜 인수를 검색하여 적절한 작업을 수행해야 합니다.

시스템 콜은 외부 CPU에서 발생하는 인터럽트와 마찬가지로, 소프트웨어 예외(exception)를 통해 발생할 수 있습니다. 이러한 예외는 페이지 폴트나 0으로 나누기 등의 오류뿐만 아니라, 사용자 프로그램이 운영 체제로 서비스를 요청하는 수단("시스템 콜")이 됩니다.

전통적인 x86 아키텍처에서 시스템 콜은 다른 소프트웨어 예외와 같은 방식으로 처리됩니다. 그러나 x86-64에서는 제조업체가 시스템 콜을 위한 특별한 명령어인 syscall을 도입했습니다. 이를 통해 시스템 콜 핸들러를 빠르게 호출할 수 있습니다.

현재 x86-64에서는 syscall 명령어가 가장 일반적으로 사용되는 시스템 콜 호출 방법입니다. Pintos에서는 사용자 프로그램이 시스템 콜을 호출하기 위해 syscall을 사용합니다. 시스템 콜 번호와 추가 인수는 syscall 명령어를 호출하기 전에 레지스터에 일반적인 방식으로 설정되어야 하지만, 두 가지 주의할 점이 있습니다:

%rax 레지스터는 시스템 콜 번호를 저장합니다. 네 번째 인수는 %rcx가 아닌 %r10에 저장됩니다.

따라서, 시스템 콜 핸들러인 syscall_handler()가 제어를 얻으면, 시스템 콜 번호는 rax에 있으며, 인자는 %rdi, %rsi, %rdx, %r10, %r8 및 %r9의 순서로 전달됩니다.

```c
void syscall_handler(struct intr_frame *f UNUSED)
{
	uint64_t num = f->R.rax;
	uint64_t arg1 = f->R.rdi;
	uint64_t arg2 = f->R.rsi;
	uint64_t arg3 = f->R.rdx;
	uint64_t arg4 = f->R.r10;
	uint64_t arg5 = f->R.r8;
	uint64_t arg6 = f->R.r9; }
```



호출자의 레지스터는 struct intr_frame에 전달됩니다. (struct intr_frame은 커널 스택에 있습니다.)

함수 반환 값에 대한 x86-64 규칙은 RAX 레지스터에 넣는 것입니다. 값을 반환하는 시스템 콜은 struct intr_frame의 rax 멤버를 수정하여 값을 반환할 수 있습니다.



파일에서는 다른 시스템 콜도 정의되어 있습니다. 현재는 무시하십시오. 이 중 일부는 프로젝트 3에서 구현하고 나머지는 프로젝트 4에서 구현하게 될 것이므로 확장 가능성을 염두에 두고 시스템을 설계해야합니다.

여러 사용자 프로세스가 동시에 시스템 콜을 수행 할 수 있도록 동기화해야합니다. 특히, filesys 디렉토리에서 제공되는 파일 시스템 코드에서 동시에 여러 스레드에서 호출하는 것은 안전하지 않습니다. 시스템 콜 구현은 파일 시스템 코드를 임계 영역으로 처리해야합니다. 또한 process_exec()도 파일에 액세스하므로 이를 염두에 두십시오. 현재는 filesys 디렉토리의 코드를 수정하는 것을 권장하지 않습니다.



## Deny Write on Executables

실행 파일에 대한 쓰기 권한을 거부합니다.

실행 중인 파일이 디스크에서 변경중인 코드를 실행하려고 할 때 예측 할 수 없는 결과가 발생 할 수 있기 때문에 많은 운영 체제에서 파일에 대한 쓰기를 거부합니다. 이것은 특히 프로젝트3 에서 가상 메모리가 구현 된 후에 매우 중요하지만, 지금 시점에서도 문제가 발생할 수 있습니다.

file_deny_write()를 사용하여 열려있는 파일에 대한 쓰기를 방지 할 수 있습니다. 파일에 대한 file_allow_wirte() 호출은 쓰기 권한을 다시 활성화 합니다. (파일이 다른 opener에 의해 쓰기가 거부되지 않은 경우) 파일을 닫으면 쓰기 권한이 다시 활성화됩니다. 따러서 프로세스의 실행 파일에 대한 쓰기를 거부하려면 프로세스가 계속 실행 중인 동안 파일을 열어 둘 필요가 있습니다.











system call 66page시작

