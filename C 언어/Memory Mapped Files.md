## Memory Mapped Files

mmap 과 munmap은 메모리 매핑된 파일을 위한 두 개의 시스템 호출입니다. VM시스템은 mmap영역에서 페이지를 게으르게 로드하고, 매핑된 파일 자체를 백업 저장소로 사용해야 합니다. 이를 구현하기 위해 vm/file.c에 정의된 do_mmap과 do_munmap을 구현하고 사용해야 합니다.ㄹ

이를 구현하기 위해 vm/file.c에 정의된 do_mmap과 do_munmap을 구현하고 사용해야 합니다.

```c
void *mmap (void *addr, size_t length, int writable, int fd, off_t offset);
```

> fd로 열린 파일의 offset 바이트부터 시작하여 길이가 length인 파일을 프로세스의 가상 주소 공간인 addr에 매핑합니다. 전체 파일은 addr에서 시작하는 연속적인 가상 페이지에 매핑됩니다. 파일의 길이가 PGSIZE의 배수가 아닌 경우, 최종 매핑된 페이지에 일부 바이트가 파일의 끝을 벗어나게 됩니다. 이 페이지가 폴트인될 때 이러한 바이트를 0으로 설정하고, 페이지가 디스크에 다시 기록될 때 이를 폐기합니다. 성공하면 파일이 매핑된 가상 주소를 반환합니다. 실패한 경우에는 유효하지 않은 주소인 NULL을 반환해야 합니다.



mmap 호출은 다음의 경우에 실패할 수 있습니다. 만약 fd로 열린 파일의 길이가 0바이트라면 실패해야 합니다. addr이 페이지에 정렬되어 있지 않거나, 매핑된 페이지의 범위가 스택이나 실행 파일 로드 시 매핑된 페이지와 겹치는 경우에도 실패해야 합니다. Linux에서는 addr이 NULL인 경우, 커널이 매핑을 생성할 적절한 주소를 찾습니다. 단순성을 위해 주어진 addr에 mmap을 시도할 수 있습니다. 따라서  addr이 0인 경우에는 실패해야 합니다. 왜냐하면 Pintos 코드에서 가상 페이지 0이 매핑되지 않았다고 가정하기 때문입니다. mmap은 또한 length가 0인 경우에도 실패해야 합니다. 마지막으로, 콘솔 입력과 출력을 나타내는 파일 디스크립터는 매핑할 수 없습니다.

메모리 매핑된 페이지는 익명 페이지와 마찬가지로 게으르게 할당되어야 합니다. vm_alloc_page_with_initializer 또는 vm_alloc_page를 사용하여 페이지 객체를 만들 수 있습니다.



```c
void munmap (void *addr);
```

> 지정된 주소 범위  addr에 대한 매핑을 해제합니다. 이 주소는 이전에 동일한 프로세스에 의해 호출된  mmap 호출에 의해 반환된 가상 주소여야 하며 아직 매핑이 해제 되지 않은 것이어야 합니다.



모든 매핑은 프로세스가 종료될 때 묵시적으로 매핑이 해제 됩니다. 이는 exit를 통해 종료되거나 다른 방법을 통해 종료되더라도 해당됩니다. 매핑이 묵시적으로든 명시적으로든 해제되면, 프로세스에 의해 작성된 모든 페이지는 파일에 다시 기록되어햐 하며, 기록되지 않은 페이지는 기록되지 않아야 합니다.  그런 다음 이 페이지들은 프로세스의 가상 페이지 목록에서 제거됩니다.  

파일을 닫거나 제거하는 것은 해당 파일의 매핑을 해제 하지 않습니다.  매핑이 생성된 후에는 munmap  이 호출 되거나 프로세스가 종료될 때까지 유효합니다.  이는 Unix 규칙을 따릅니다. 자세한 내용은 "Removing an Open File"을 참조하십시오. 각 매핑의 독립적인 참조를 얻기 위해 file_reopen 함수를 사용해야 합니다.

동일한 파일을 두 개 이상의 프로세스가 매핑하는 경우, 일관된 데이터를 보장할 필요가 없습니다. Unix는 두 매핑이 동일한 물리적 페이지를 공유하도록 처리하며, mmap 시스템 호출에는 페이지가 공유되는지 또는 개인적인지 (즉, 복사 시에만 작성되는지)를 지정할 수 있는 인수도 있습니다. 

필요에 따라 vm/vm.c의 vm_file_init 및 vm_file_initializer를 수정할 수 있습니다.



```c
void vm_file_init (void);
```

> vm_file_init 함수는 파일을 백업으로 사용하는 페이지 서브시스템을 초기화합니다. 이 함수에서는 파일 백업 페이지와 관련된 모든 설정을 수행할 수 있습니다. 



```c
bool file_backed_initializer (struct page *page, enum vm_type type, void *kva);
```

> 파일을 백업으로 사용하는 페이지를 초기화합니다. 이 함수는 먼저 page->operarions 에서 파일을 백업으로 사용하는 페이지에 대한 핸들러를 설정합니다. 
>
> 페이지 구조체(page struct)에 메모리를 백업하는 파일과 같은 몇 가지 정보를 업데이트 하는 것이 좋을 수 있습니다.



```c
static void file_backed_destroy (struct page *page);
```

> 연관된 파일을 닫아 파일 백업 페이지를 파괴합니다. 내용이 변경된 경우 변경 사항을 파일에 기록해야 합니다. 이 함수에는 페이지 구조체를 해제할 필요가 없습니다. file_backed_destory의 호출자가 처리해야 합니다.