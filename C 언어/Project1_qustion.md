## Alarm Clock

**제공된 작동 구현은 작업을 기다리는 동안 현재 시간을 확인하고 thread_yield()를 호출하는 루프에서 계속해서 반복되는 "busy waiting" 방식을 사용합니다. 이를 회피하기 위해 busy waiting 없이 다시 구현해보세요.**

> 호출한 스레드의 실행을 일정 시간이 지날 때까지 중단시킵니다. 시스템이 휴면 상태가 아닌 한, 스레드가 정확히 x tick 후에 깨어나지 않아도 됩니다. 그냥 올바른 시간만큼 대기한 후에 준비 큐에 넣으세요.

`timer_sleep()` 함수는 커서를 1초마다 깜빡이게 하기와 같이 실시간으로 작동하는 스레드에 유용합니다. `timer_sleep()` 함수의 인자는 타이머 틱(tick) 단위로 표현됩니다. 밀리초나 다른 단위가 아닙니다. `devices/timer.h` 파일에서 정의된 `TIMER_FREQ` 매크로에서 1초당 발생하는 타이머 틱 수를 확인할 수 있습니다. 이 매크로의 기본값은 `100`입니다. 이 값을 변경하는 것은 많은 테스트 케이스가 실패할 가능성이 있기 때문에 권장하지 않습니다.

일정한 시간(밀리초, 마이크로초, 나노초)동안 스레드를 중지시키는 `timer_msleep()`, `timer_usleep()`, `timer_nsleep()` 함수도 있습니다. 하지만 이러한 함수들은 필요한 경우 `timer_sleep()` 함수를 자동으로 호출합니다. 이 함수들은 수정하지 않아도 됩니다. 이번 프로젝트 이후에도 알람 클록 구현은 필요하지 않습니다. 하지만 프로젝트 4에서 유용할 수 있습니다.



## Priority Scheduling

현재 실행중인 스레드의 우선순위보다 높은 우선순위를 갖는 스레드가 준비 리스트(ready list)에 추가될 때는, 현재 스레드는 바로 새로운 스레드에게 프로세서를 양보해야 합니다. 마찬가지로, 락(lock), 세마포어(semaphore), 혹은 조건 변수(condition variable)를 기다리는 스레드는, 가장 높은 우선순위를 갖는 스레드가 먼저 깨어나야 합니다. 스레드는 언제든지 자신의 우선 순위를 높이거나 낮출 수 있지만 더 이상 가장 높은 우선 순위를 가지지 않도록 우선 순위를 낮추면 즉시 CPU를 양보해야 합니다.

스레드 우선순위는 PRI_MIN(0)에서 PRI_MAX(63)까지 범위를 가집니다. 낮은 숫자가 낮은 우선순위를 의미하므로, 우선순위 0이 가장 낮고, 우선순위 63이 가장 높습니다. 스레드 생성 시 초기 우선순위는 thread_create()의 인자로 전달됩니다. 다른 우선순위를 선택할 이유가 없다면 PRI_DEFAULT(31)를 사용하면 됩니다. PRI_ 매크로는 threads/thread.h에 정의되어 있으며, 값을 변경해서는 안 됩니다.

우선순위 스케줄링에서 발생하는 문제 중 하나는 "우선순위 역전(priority inversion)"입니다. 고우선순위(H), 중간우선순위(M), 저우선순위(L) 스레드가 있다고 가정해봅시다. 만약 H가 L(예를 들어 L이 소유한 락(lock)을 기다리는 경우)를 기다려야 하고, 동시에 M이 준비 리스트(ready list)에 있다면, H는 낮은 우선순위 스레드가 CPU 시간을 사용하지 않기 때문에 CPU를 절대 얻지 못할 것입니다. 이 문제의 부분적인 해결책은, H가 L이 락을 보유하는 동안 자신의 우선순위를 L에게 "기부(donate)"하고, L이 락을 해제하면 다시 우선순위를 가져오는 것입니다.

우선순위 기부(priority donation)를 구현하세요. 우선순위 기부가 필요한 모든 다양한 상황을 고려해야 합니다. 하나의 스레드에 대해 여러 우선순위가 기부되는 경우도 처리해야 합니다. 또한 중첩된(priority donation) 기부를 처리해야 합니다. 예를 들어, H가 M이 보유한 락을 기다리고 M이 L이 보유한 락을 기다리는 경우, M과 L 모두 H의 우선순위로 상승해야 합니다. 필요한 경우 중첩된 우선순위 기부 깊이에 합리적인 제한(예: 8단계)을 두어도 괜찮습니다.

락(lock)에 대해 우선순위 기부(priority donation)를 구현해야 합니다. 다른 Pintos 동기화 구조체에 대한 우선순위 기부는 구현할 필요가 없습니다. 모든 경우에 우선순위 스케줄링(priority scheduling)을 구현해야 합니다.

마지막으로, 스레드가 자신의 우선순위를 검사하고 수정할 수 있는 다음 함수를 구현해야 합니다. 이 함수들의 뼈대는 threads/thread.c에 제공됩니다.

```c
void thread_set_priority (int new_priority);
```

현재 스레드의 우선순위를 새로운 우선순위로 설정합니다. 현재 스레드가 더 이상 가장 높은 우선순위를 가지지 않으면 양보(yield)됩니다.

```c
int thread_get_priority (void);
```

현재 스레드의 우선순위를 반환합니다. 우선순위 기부(priority donation)가 있는 경우 높은 우선순위(기부된 우선순위)를 반환합니다.



## Advanced Scheduler

**4.4BSD 스케줄러와 유사한 다단계 피드백 큐 스케줄러를 구현하여 시스템에서 실행 중인 작업의 평균 응답 시간을 줄이세요.**

우선순위 스케줄러와 마찬가지로, 고급 스케줄러는 우선순위에 따라 실행할 스레드를 선택합니다. 그러나 고급 스케줄러는 우선순위 기부를 수행하지 않습니다. 따라서 고급 스케줄러를 시작하기 전에 우선순위 기부를 제외하고 우선순위 스케줄러가 작동하도록 권장합니다.

코드를 작성하여 Pintos 시작 시 스케줄링 알고리즘 정책을 선택할 수 있도록 해야 합니다. 기본적으로 우선순위 스케줄러가 활성화되어 있어야 하지만, `-mlfqs` 커널 옵션으로 4.4BSD 스케줄러를 선택할 수 있어야 합니다. 이 옵션을 전달하면 `parse_options()`에서 옵션을 구문 분석할 때 `thread.h`에 선언된 `thread_mlfqs`가 true로 설정됩니다. 이는 `main()`초기에 발생합니다.

4.4BSD 스케줄러가 활성화되면 스레드는 더 이상 직접 자신의 우선순위를 제어하지 않습니다. `thread_create()`에 전달되는 우선순위 인수는 무시되어야 하며, `thread_set_priority()` 호출과 `thread_get_priority()`는 스케줄러에 의해 설정된 스레드의 현재 우선순위를 반환해야 합니다. 고급 스케줄러는 이후의 프로젝트에서 사용되지 않습니다.