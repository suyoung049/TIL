## Project1: Threads

이 과제에서는 최소한의 기능을 갖춘 스레드 시스템을 제공합니다. 동기화 문제에 대한 이해를 높이기 위해 이 시스템의 기능을 확장하는 것이 여러분의 업무입니다. 이 과제에서는 주로 `threads` 디렉토리에서 작업하며, `devices` 디렉토리에서 일부 작업을 수행합니다. 컴파일은 `threads` 디렉토리에서 수행해야 합니다. 이 프로젝트의 설명을 읽기 전에 동기화 자료를 적어도 훑어보는 것이 좋습니다.



### Background

#### Understanding Threads

첫 번째 단계는 초기 스레드 시스템의 코드를 읽고 이해하는 것입니다. Pintos는 이미 스레드 생성 및 완료, 스레드 간 전환을 위한 간단한 스케줄러, 그리고 동기화 기본 요소(세마포어, 락, 조건 변수 및 최적화 장벽)를 구현하고 있습니다.

일부 코드는 조금 신비롭게 보일 수 있습니다. 이전 소개에서 설명한 대로 기본 시스템을 컴파일하고 실행하지 않은 경우 이를 먼저 수행해야 합니다. 코드 일부를 읽어보면 무슨 일이 일어나는지 볼 수 있습니다. 원한다면 `printf()` 호출을 거의 어디에나 추가하여 다시 컴파일하고 실행하여 어떤 순서로 일어나는지 확인할 수 있습니다. 또한 디버거에서 커널을 실행하고 흥미로운 지점에 중단점을 설정하고 코드를 단계별로 실행하고 데이터를 검사할 수 있습니다.

쓰레드가 생성될 때, 스케줄링될 새로운 컨텍스트가 생성됩니다. `thread_create()` 함수의 인자로 실행될 함수를 제공합니다. 쓰레드가 처음 스케줄링되어 실행될 때, 해당 함수의 시작 부분부터 실행되며, 해당 컨텍스트에서 실행됩니다. 함수가 반환되면, 쓰레드가 종료됩니다. 각각의 쓰레드는 따라서 Pintos 내에서 실행되는 미니 프로그램처럼 작동하며, `thread_create()` 함수로 전달된 함수가 `main()` 함수처럼 작동합니다.

주어진 시간에 정확히 하나의 스레드가 실행되며, 나머지 스레드는 비활성화됩니다. 스케줄러는 다음에 실행할 스레드를 결정합니다. (주어진 시간에 실행할 준비가 된 스레드가 없으면, `idle()`에 구현된 특수한 idle 스레드가 실행됩니다.) 동기화 primitive는 한 스레드가 다른 스레드의  어떤 작업이 수행되기를 기다리는 경우 컨텍스트 스위치(context switch)를 강제할 수 있습니다.

컨텍스트 스위치의 작동 방식은 `threads/thread.c`의 `thread_launch()` 함수에 구현되어 있습니다. 현재 실행중인 스레드의 상태를 저장하고 전환할 스레드의 상태를 복원합니다.

GDB 디버거를 사용하여 컨텍스트 스위치를 천천히 추적하여 무슨 일이 일어나는지 살펴보세요(GDB 참조). 먼저 `schedule()` 함수에 중단점을 설정한 다음, 거기서부터 단계별로 진행하면 됩니다. 각 스레드의 주소와 상태, 그리고 각 스레드의 호출 스택에 어떤 프로시저가 있는지 주의해서 기록하세요. `do_iret()`에서 `iret`을 실행하면 다른 스레드가 실행되는 것을 알 수 있습니다.

참고: Pintos에서 각 스레드는 크기가 작고 고정된 실행 스택을 할당받으며 크기는 약 4 KB입니다. 커널은 스택 오버플로우를 감지하려고 노력하지만 완벽하게는 할 수 없습니다. 대규모 데이터 구조를 비정적 지역 변수로 선언하는 경우 (예: int buf[1000];)와 같은 이상한 문제, 예를 들어 수수께끼 같은 커널 패닉이 발생할 수 있습니다. 스택 할당 대안으로는 페이지 할당기 및 블록 할당기(메모리 할당 참조)가 있습니다.

### Synchronization

적절한 동기화는 이러한 문제의 해결에 중요한 역할을 합니다. 모든 동기화 문제는 interrupts를 끄면 쉽게 해결할 수 있습니다: interrupts가 꺼져 있으면 병행성이 없으므로 경쟁 상태가 발생할 가능성이 없습니다. 따라서 이 방법으로 모든 동기화 문제를 해결하는 것이 유혹적일 수 있지만, 그렇게 하지 마세요. 대신, 세마포어, 락, 조건 변수를 사용하여 대부분의 동기화 문제를 해결하세요. 동기화에 대한 가이드 섹션 (Synchronization 참조) 또는 `threads/synch.c`의 주석을 참조하여 어떤 상황에서 어떤 동기화 원칙을 사용해야 하는지 확인하세요.

Pintos 프로젝트에서 interrupts를 비활성화하여 가장 잘 해결되는 유일한 문제 클래스는 kernel thread와  interrupts handlers 간에 공유되는 데이터를 조정하는 것입니다. interrupts handlers는 sleep 되지 않기 때문에 locd을 획득할 수 없습니다. 이는 kernel thread와 interrupts handlers 간에 공유되는 데이터가 interrupts를 꺼서 kernel thread내에서 보호되어야 함을 의미합니다.

This project only requires accessing a little bit of thread state from interrupt handlers 

alarm clock에서  timer interrupt는 slip 상태에 있는 thread를 깨워야 합니다. 고급 스케줄러에서는 timer interrupt가 몇 개의 글로벌 및 스레드별 변수에 액세스해야 합니다. 이러한 변수들에 대해 커널 스레드에서 액세스할 때는, 타이머 인터럽트가 방해하지 않도록 인터럽트를 비활성화해야 합니다.

interrupts를 끄는 경우, 최소한의 코드 부분에서만 interrupt를 끄도록 주의해야 합니다. 그렇지 않으면 timer tick이나 input events와 같은 중요한 것들을 놓칠 수 있습니다. 또한 interrupt를 끄는 것은 interrupt 처리 대기 시간을 증가시키기 때문에, 너무 과도하게 사용하면 시스템의 반응성이 떨어질 수 있습니다.

동기화 기본 요소인 `synch.c` 내에서는 인터럽트를 비활성화하여 구현됩니다. 여기서 인터럽트를 비활성화하여 실행되는 코드의 양을 늘려야 할 수 있지만, 최소한으로 유지해야 합니다.

디버깅에 유용하게 인터럽트를 비활성화할 수 있습니다. 코드를 제출하기 전에 디버깅 코드를 제거해야 합니다. (주석 처리하는 대신, 코드를 지우는 것이 좋습니다.)

제출한 코드에서는 busy waiting가 없어야 합니다. thread_yield()를 호출하는 tight loop는 busy waiting의 한 형태입니다.



#### Priority donation

우선순위 기부(Priority donation)는 다른 스레드나 프로세스가 현재 실행 중인 스레드의 작업을 방해하고 있을 때, 해당 스레드의 우선순위를 높여주는 방식입니다. 이를 통해 스레드의 빠른 처리를 돕고, 전반적인 시스템 성능을 향상시키는데 사용됩니다.



#### round-robin 스케쥴러

라운드 로빈(Round-robin) 스케줄러는 컴퓨터 시스템에서 프로세스 스케줄링에 사용되는 알고리즘 중 하나입니다. 이 알고리즘은 시분할 시스템에서 CPU 시간을 할당하기 위해 사용됩니다.

라운드 로빈 스케줄러는 여러 개의 프로세스가 동시에 실행될 때, 각각 일정 시간 동안 CPU를 사용하도록 할당하는 방식입니다. 이 할당 시간은 미리 정해진 시간(quantum)으로 설정되어 있으며, 이 시간이 지나면 CPU는 다른 프로세스로 전환됩니다. 이러한 방식으로 각 프로세스는 일정 시간마다 CPU를 할당받아 실행됩니다.

라운드 로빈 스케줄링은 간단하고 공정한 스케줄링 알고리즘으로, 모든 프로세스가 동등한 기회를 가지도록 보장합니다. 그러나 할당 시간이 작게 설정될 경우, 프로세스 전환이 빈번하게 일어나 CPU 사용 효율이 떨어질 수 있으며, 반대로 할당 시간을 크게 설정할 경우 응답시간이 길어질 수 있습니다.



#### 이진 세마포어 데드락 케이스

1. 세마포어 P와 세마포어 Q가 있고, 두 개의 프로세스가 P를 먼저 얻고, Q를 얻기 위해 대기하고 있습니다. 그런 다음, 두 개의 프로세스가 동시에 P를 놓고 Q를 얻으려고 시도합니다. 이때, 두 개의 프로세스가 서로 Q를 얻기 위해 대기하게 되어 데드락이 발생합니다.
2. 두 개 이상의 프로세스가 세마포어 P를 얻으려고 시도합니다. 그러나, P가 이미 다른 프로세스에 의해 얻어졌기 때문에 모든 프로세스는 P를 얻지 못하고 대기합니다. 그런 다음, 다른 세마포어 Q를 얻기 위해 대기하고 있던 두 개 이상의 프로세스가 Q를 얻으려고 시도합니다. 이때, 모든 프로세스가 Q를 얻을 수 없기 때문에 데드락이 발생합니다.
3. 두 개의 세마포어 P와 Q가 있고, 두 개의 프로세스가 P를 얻고 Q를 대기하고 있습니다. 그런 다음, 두 개의 프로세스가 동시에 Q를 얻으려고 시도합니다. 그러나, Q가 이미 다른 프로세스에 의해 얻어졌기 때문에 두 개의 프로세스가 모두 Q를 얻지 못하고 대기하게 되어 데드락이 발생합니다.

이러한 경우들에서는 프로세스가 서로 무한정으로 대기하게 되어, 데드락 상태가 발생할 수 있습니다. 따라서, 이러한 상황을 방지하기 위해서는 데드락을 예방하는 알고리즘을 사용하거나, 데드락이 발생했을 때 이를 탐지하고 회피하는 알고리즘을 사용해야 합니다.



#### 데드락 예방 알고리즘

1. 상호배제(Mutual Exclusion) 예방: 하나의 자원에 대해 한 번에 하나의 프로세스만 접근할 수 있도록 합니다. 이를 위해서는 세마포어와 뮤텍스 등의 동기화 기법을 사용할 수 있습니다.
2. 점유와 대기(Hold and Wait) 예방: 프로세스가 다른 자원을 점유하면서 새로운 자원을 요청할 때, 이미 점유한 자원을 놓고 다시 요청하는 것이 아니라, 모든 자원을 한번에 요청하도록 합니다.
3. 비선점(Non-preemption) 예방: 프로세스가 자원을 점유하고 있을 때, 다른 프로세스가 그 자원을 빼앗아 사용할 수 없도록 합니다.
4. 순환 대기(Circular Wait) 예방: 자원들에게 번호를 매기고, 프로세스가 자원을 요청할 때 번호순으로 요청할 수 있도록 합니다.

데드락을 탐지하고 회피하는 알고리즘은 다음과 같습니다:

1. 자원 할당 그래프 알고리즘(Resource Allocation Graph Algorithm): 자원 할당 그래프를 사용하여 데드락 상태를 탐지합니다. 자원 할당 그래프는 프로세스와 자원을 정점으로 표현하고, 간선은 자원 할당 및 요청 관계를 나타냅니다. 데드락 상태는 자원 할당 그래프에서 사이클이 발생할 때 발생합니다.
2. 은행원 알고리즘(Banker's Algorithm): 프로세스가 자원을 요청할 때, 시스템이 안정 상태로 유지될 수 있는지 사전에 계산하여 자원을 할당하는 알고리즘입니다. 프로세스가 자원을 요청할 때, 시스템이 데드락 상태에 빠질 가능성이 있는지를 먼저 체크하고, 데드락이 발생하지 않을 경우에만 자원을 할당합니다. 이를 통해 데드락 상태를 회피할 수 있습니다.



#### 기아현상

기아 현상(Starvation)이란, 운영 체제에서 프로세스나 스레드가 원하는 자원을 계속해서 기다리는 상황이 발생하여 자원을 제공받지 못하고 영원히 대기하는 현상을 말합니다.

기아 현상은 다른 프로세스나 스레드가 자원을 사용하는 데 문제가 없는 상황에서도 특정 프로세스나 스레드가 자원을 사용하지 못하는 문제를 일으키기 때문에 심각한 문제가 될 수 있습니다. 특히, 긴 시간 동안 자원을 할당받지 못하면서 기다리는 경우 프로세스나 스레드의 실행 시간이 지연되고, 전체적인 시스템 성능에 영향을 미칠 수 있습니다.

기아 현상은 일반적으로 우선순위(Inversion) 역전, 공정하지 않은 스케줄링 알고리즘 등에 의해 발생할 수 있습니다. 이러한 문제를 해결하기 위해서는 공정한 우선순위 스케줄링 알고리즘, 우선순위 상속 등의 기술을 사용하여 기아 현상을 방지할 수 있습니다.



#### 교착 상태 발생 조건

교착상태가 발생하기 위해서는 네 가지 조건이 충족되어야 한다.

- 상호 배체(Mutual Exclusion): 쓰레드가 자신이 필요로 하는 자원에 대한 독자적인 제어권을 주장한다(예, 쓰레드가 락을 획득함)
- 점유 및 대기(Hold-and-wait): 쓰레드가 자신에게 할당된 자원(예: 이미 획득한 락)을 점유한 채로 다른 자원(예: 획득하고자 하는 락)을 대기한다.
- 비 선점(No preemption): 자원(락)을 점유하고 있는 쓰레드로부터 자원을 강제적으로 빼앗을 수 없다.
- 환형 대기(Circular wait): 각 쓰레드는 다음 쓰레드가 요청한 하나 또는 그 이상의 자원(락)을 갖고 있는 쓰레드들의 순환고리가 있다.

```c
void put_to_sleep_thread(int wake_up_tick)
{
	enum intr_level old_level = intr_disable();
	struct thread *t = thread_current();
	t->wake_up_tick = wake_up_tick;
	struct thread *sleep_thread;
	struct list_elem *last = list_end(&sleep_list);
	if (!list_empty(&sleep_list))
	{
		for (struct list_elem *e = list_front(&sleep_list); e != list_end(&sleep_list); e = list_next(e))
		{
			sleep_thread = list_entry(e, struct thread, elem);
			if (t->wake_up_tick < sleep_thread->wake_up_tick)
			{
				last = e;
				break;
			}
		}
	}

	list_insert(last, &t->elem);
	t->status = THREAD_BLOCKED;
	schedule();

	intr_set_level(old_level);
}
```



### Priority in PinsOS

- priority ranges from `PRI_MIN(=0)` to `PRI_MAX(=63)`
  - 0 ~ 63의 총 64의  priority levels
  - 수가 커질수록, 우선 순위가 높음
  - 디폴트는 `PRI_DEFAULT(=31)`
- Pintos는 thread가 `thread_create()` 에 의해 생성 될때, 최초의 우선순위를 세팅
- Exisiting function
  - `void thread_set_priority (int new_priority)`
    - current thread를 `new_priotity`로 변경
  - `int thread_get_priotity(void)`
    - current thread의 우선순위를 반환



### 설계 방향

- read list에 우선순위 순으로 thread를 삽입하기 (확장이 불가능함)
- thread가 ready list에 추가 될때, new thread와 curent thread의 우선순위를 비교
- new thread의 우선순위가 높으면,  ` schedule()`을 호출 



### others to modify

- `void thread_unblock(struct thread *t)`
  - thread가 unblock상태이면, 우선순위 순서에 의해 ready_list에 삽입됨
- `void thread_yield(void)`
  - current thread가  CPU를 양보하고, 우선순위 순서에 의해 ready_li에 삽입됨
- `void thread_set_priority(int new_priority)`
  - current thread의 우선순위를 셋팅
  - ready_list를 recoder



`thread_unblock()`

- thread를 unblocking할 때, `list_push_back()` 대신, `list_insert_ordered()`를 이용



###  FIFO lock/unlock in priority-less PintOS

- lock은 우선 순위를 무시하고, `waiters` list에 있는 FIFO순에 의해 획득
  - A는 현재 lock을 
