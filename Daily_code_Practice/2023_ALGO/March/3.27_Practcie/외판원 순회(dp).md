## 외판원 순회(dp)

### 풀이

먼저 문제에서 항상 순회할 수 있는 경우만 주어진다고 했으므로 어느 한 점을 임의로 잡아서 그 점에서 시작해 최소 비용으로 다시 돌아오는 경로를 찾으면 된다. 

왜냐하면 만약 점 2에서 시작할 때 2 -> 1 -> 3 -> 2 가 최소비용 경로라고 한다면 1에서 시작할 때도 1-> 3 -> 2 -> 1이라는 동일한 최소 비용 경로가 존재하기 때문이다.

그리고 이번 문제에서는 비트마스킹을 사용해 방문체크를 한다. 비트마스킹을 이용했을 때 장점은 크게 3가지가 있다.



##### 비트 마스킹의 장점

1.  빠른 수행시간

   1. 컴퓨터와 가까운 2진수를 사용하기에 연산속도가 굉장히 빠르다고 한다. 하나의 연산만 놓고 보면 10진수와 차이가 크지 않겠지만 연산을 굉장히 많이 수행하는 상황에는 눈에 띄는 차이를 볼 수 있을 것이다.

2. 적은 메모리

   1. 쉽게 말해 10bit 짜리 이진수 하나로 210가지의 경우의 수를 표현이 가능하다. 아래와 같은 방문을 체크하는 배열을

      [1,0,0,1,1,1,0,0,1,1] 을 1001110011와 같이 이진수 하나로 표현할 수 있는 것이다.

3. 비트 연사자를 이용한 짧고, 깔끔한 코드



다시 문제 풀이로 돌아오면 방문해야하는 점들 만큼의 길이를 가진 2진수를 만들어 이를 이용해 방문한 점들을 체크 하는 것이다.

예를 들어 2진수 10(=2)은 두 번째 점을 방문했다는 뜻이다. 이어서 2진수 110(= 6)은 두 번째, 세 번째 점을 방문했다는 뜻이다.

이제 이를 이용해 문제를 풀어보겠다.



##### 비트연산

`A & (1<<B)`

먼저 << 는 지정한 수만큼 비트를 전부 왼쪽으로 이동시키는 left shift 연산이다 쉽게 말하자면 2진수 에서 모든 1을 옆으로 지정한 수만큼 이동시키는 것이다.  예를 들어 1 << 2 = 100, 101 << 2 는 10100이 된다. 당연히 오른쪽으로 이동시키는 right shift 도 존재한다.

이어서 &은 대응되는 비트가 모두 1이면 1을 반환하는 비트 AND 연산이다. 10101 & 10011 = 10001 

`A | (1 <<B )`

다음으로 |는 대응되는 비트 중에서 하나라도 1이면 1을 반환하는 비트 OR 연산이다.

10000|1111 = 11111

`A & ~(1<<B)`

마지막으로 ~는 비트를 1이면 0으로, 0이면 1로 반전 시키는 비트 NOT 연산이다.

~ 10100 != 1011

~10100 = 11101011
