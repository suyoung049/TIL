## TypeScript

#### 제네릭 배열

제네릭 배열은 TypeScript에서 배열의 요소 유형을 지정하기 위해 사용되는 제네릭(Generic) 타입입니다. 제네릭은 타입 안정성을 갖추면서 재사용 가능한 코드를 작성할 수 있게 해줍니다.

예를 들어, 다음은 `Array<T>` 형태의 제네릭 배열 타입을 사용하는 TypeScript 코드입니다:

```javascript
let numbers: Array<number> = [1, 2, 3, 4, 5];
let strings: Array<string> = ['Hello', 'World'];

// 위의 코드에서 Array<number>는 number 요소를 갖는 배열을 나타내고,
// Array<string>은 string 요소를 갖는 배열을 나타냅니다.

numbers.push(6);
// numbers 배열에는 숫자만 추가할 수 있습니다.
// numbers.push('seven'); // 에러: 문자열은 numbers 배열에 추가할 수 없습니다.

strings.push('!');
// strings 배열에는 문자열만 추가할 수 있습니다.
// strings.push(123); // 에러: 숫자는 strings 배열에 추가할 수 없습니다.
```

위의 코드에서 `Array<number>`는 number 타입의 요소를 가진 배열을, `Array<string>`은 string 타입의 요소를 가진 배열을 나타냅니다. 이렇게 배열을 생성할 때 제네릭 타입을 사용하면 배열에 저장할 수 있는 요소의 유형을 지정할 수 있습니다. 이를 통해 배열에 잘못된 유형의 값을 추가하는 오류를 방지할 수 있습니다.

제네릭 배열은 다양한 데이터 유형에 대한 배열을 선언하고, 컴파일러가 타입 검사를 수행하도록 도와줍니다.

#### 제네릭 배열 VS 배열

제네릭 배열을 사용하는 것과 일반 배열을 사용하는 것 사이에는 몇 가지 주요한 차이점이 있습니다.

1. 타입 안정성: 제네릭 배열은 배열의 요소 유형을 명시적으로 지정하므로 타입 안정성을 제공합니다. 컴파일러는 제네릭 배열에 잘못된 유형의 값을 추가하려고 할 때 경고 또는 오류를 표시하여 미리 탐지할 수 있습니다. 일반 배열은 타입 안정성을 보장하지 않으며, 모든 유형의 값을 배열에 추가할 수 있습니다.
2. 코드 가독성: 제네릭 배열을 사용하면 코드의 의도를 명확하게 표현할 수 있습니다. 배열의 요소 유형이 명시되므로 다른 개발자가 코드를 읽거나 유지보수할 때 더 이해하기 쉽습니다.
3. 재사용성: 제네릭 배열을 사용하면 동일한 유형의 요소를 가진 배열을 다른 함수나 클래스에서 재사용할 수 있습니다. 제네릭을 사용하지 않는 경우에는 다른 유형의 배열을 사용하기 위해 새로운 코드를 작성해야 합니다.
4. 타입 추론: 제네릭 배열을 사용하면 컴파일러가 배열의 요소 유형을 추론할 수 있습니다. 따라서 명시적으로 타입을 지정하지 않아도 됩니다. 예를 들어, `const numbers = [1, 2, 3]`와 같이 배열을 선언하면 numbers 변수는 number[] 타입으로 추론됩니다.

그러나 말씀하신 것처럼, TypeScript에서는 제네릭 배열 대신 일반 배열을 사용할 수도 있습니다. 일반 배열은 유연성이 더 크고, 다양한 유형의 값을 포함할 수 있습니다. 제네릭 배열은 주로 타입 안정성과 코드 가독성을 강조하는 경우에 사용됩니다. 어떤 유형의 배열을 사용할지는 개발자의 선택에 달려있습니다.

#### 인터페이스 타입별칭 차이

인터페이스(Interface)와 타입 별칭(Type Alias)은 TypeScript에서 유사한 목적을 가지고 있지만 약간의 차이가 있습니다.

인터페이스는 객체의 구조를 정의하는 데 사용되는 TypeScript의 기능입니다. 주로 객체의 속성, 메서드, 클래스의 구조를 설명하기 위해 사용됩니다. 예를 들어:

```javascript
interface Person {
  name: string;
  age: number;
}

const person: Person = {
  name: 'John',
  age: 30
};
```

인터페이스는 확장(extends)이 가능하며, 클래스가 인터페이스를 구현(implement)할 수 있습니다. 인터페이스는 구조적 타이핑(structural typing)에 기반하여 호환성 검사를 수행합니다. 즉, 인터페이스는 해당 구조를 가지고 있는 객체를 허용합니다. 따라서 객체가 인터페이스를 따르는 속성과 메서드를 갖고 있다면, 해당 객체는 인터페이스와 호환됩니다.

타입 별칭은 특정 유형에 대한 별칭을 생성하는 데 사용됩니다. 복잡한 유형을 이름으로 참조하거나, 동일한 유형을 여러 번 사용할 때 유용합니다. 예를 들어:

```javascript
type Point = {
  x: number;
  y: number;
};

const p: Point = {
  x: 10,
  y: 20
};
```

타입 별칭은 인터페이스와 달리 확장되거나 구현되지 않습니다. 또한 구조적 타이핑이 아닌 이름 기반(typename-based)으로 호환성을 검사합니다. 즉, 동일한 이름을 가지는 타입끼리 호환되어야 합니다.

주요한 차이점은 다음과 같습니다:

1. 확장 및 구현: 인터페이스는 확장이 가능하며, 클래스가 인터페이스를 구현할 수 있습니다. 타입 별칭은 그렇지 않습니다.
2. 구조적 타이핑 vs 이름 기반 타이핑: 인터페이스는 구조적 타이핑을 기반으로 호환성을 검사하고, 타입 별칭은 이름 기반으로 호환성을 검사합니다.
3. 문법적 차이: 인터페이스는 `interface` 키워드를 사용하여 정의하고, 타입 별칭은 `type` 키워드를 사용하여 정의합니다.

일반적으로, 객체의 구조를 설명하거나 확장이 필요한 경우에는 인터페이스를 사용하고, 특정 유형에 대한 별칭이 필요한 경우에는 타입 별칭을 사용하는 것이 좋습니다. 그러나 선택은 개발자에게 달려있으며, 코드 스타일과 요구 사항에 따라 적절한 것을 선택하면 됩니다.



링크드 리스트 VS 배열 차이
